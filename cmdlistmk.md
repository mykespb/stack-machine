Симулятор стековой машины
====================================

Автор: Михаил Колодин  
Mkhail (myke) Kolodin

Версия 2025-05-25 2025-06-05 1.0.8

Общее
------------------------------------

Это документация к проекту "Стековая машина" (СМ),
выполненному только ради интереса
по аналогии с проектом, выполненным в г.Саратове.

Никаких обязательств и ответственности за использование либо неиспользование программы и документации автор не несёт.

Всё представленное здесь можно использовать свободно в любых мирных целях.

При перепечатке, пересылке, переиспользовании умпоминание имени автора данной (исходной) программы обязательно.

Что здесь:

Реализованы 3 программы:
- `ksmc`, компилятор в байт-код СМ,
- `ksmr`, интерпертатор байт-кода СМ,
- `ksmd`, декомпилятор байт-кода СМ,

к ним прилагаются полезные батнички и примеры кода на языке данной стековой машины (СМ).

Список команд СМ дан дважды: 
- подробно - в основном тексте,
- кратко - таблица в приложении в конце текста.

Добавлено приложение про использование данной разработки в учебном курсе по системному программированию.

Версионирование и оформление
------------------------------------

У каждой программы есть версия -- число в конце имени програмы.

Командные файлы вызывают нужные программы последней версии.

Есть номер версии `a` или `a.b` .

Программы считают несовместимыми всё с разными `a`,
а также если `b` программы-обработчика меньше `b` текста программы для обработки.

Номер версии программы может быть указан в коде как псевдокоманда
```
    version a
    version a.b
```

Команды пишутся 
- по одной на строке,
- или подряд (по нескольку в строке без явных знаков разделения).

Пробелы слева и справа от текста программы игнорируются.

Можно писать лесенкой или как угодно ещё.

Параметры команд д.б. на той же строке, что и сама команда
(напр., `byte 1`, `number 10`, `jne 1`).

Макросы и определяются, и используются (если разрешены и реализованы)
строго на отдельных строках.

Имена команд `byte`, `number` в программе не обязательны.

После неуспешной попытки разбора кода команды делается попытка прочитать команду как целое число;
- если успешно, то результат-число кладётся на стек данных,
  - причём если число в диапазоне 0.255, то как байт (byte), 
  - иначе как число (number),
- при переполнении -- ошибка.

Есть работа с символами, со строками.

Реализованы константы 'c', "string", без явных команд char, string
(без пробелов и спецсимволов внутри).

Архитектура машины
------------------------------------

- DS - стек данных (глубина 255)
    - (он же арифметический стек)
- RS - стек возвратов (глубина 255)
- IP - code pointer - указатель адреса выполняемой команды.
- DSP - data stack pointer - указатель стека данных
  - DS0 - вершина 
  - DS1 - подвершина
- RSP - return stack pointer - указатель стека возвратов
  - RS0 - вершина 
  - RS1 - подвершина
- memory - память (байтовые ячейки с номерами 0..MEM_SIZE (сейчас 0.1024), 
    значения: 0.65535)
  - м.б. в соответствии с моделью памяти (?)
- flags, флаги (флажки) - признаки особой ситуации
  - неопасные ошибки (как 'overflow):
    - FOF - overflow flag, переполнение при выполнении арифм. операции
  - опасные ошибки (все как 'error'):
    - FZD - zero divide flag, деление на ноль
    - FOM - out of memory flag, ошибка работы с памятью

Числа 
- byte: 1-байтовые (0..255) без знака,
- number: 2-байтовые, со знаком, имеют размер машинного слова в соответствии с моделью памяти
и имеют знак, обычно занимают 2 байта (-32768..+32767),
- адреса: 2-байтовые без знака.

Арифметические операции выполняются по модулю в соответствии с моделью памяти
(обычно ~+- половина максимального беззнакового значения).

Переходы м.б. только на конкретный адрес,
- в коде указываются абсолютно,
- в программе - только метками.

Система команд
------------------------------------

### Псевдокоманды

пустые строки игнорируются

`#` comment - комментарий, игнорируется
(в любом месте, до конца строки, отдельный символ = команда)

`;` comment - комментарий, игнорируется
(в любом месте, до конца строки, отдельный символ = команда)

TODO: `version a` или `version a.b`   
версия компилятора

`name`     
TODO: имя программы
- (необязательно, м.б. взято из имени файла, по умолчанию)
- (только печатные символы ASCII 32..127)

`end`      
признак конца кода
- (необязательно, = конец файла)
- (в байт-код пишется код 1=stop)
- (дальнейший текст в файле не обрабатывается;
- там могут быть комментарии и т.п.)

`label` метка   
установка метки
- (метка - положительное число 1..127)
- (повторная метка - ошибка, код не формируется)
- (метки -128..0 могут использоваться компилятором, напр., для реализации макросов)

`const` имя число
создание константы,
- её можно использовать в командах byte, number и самостоятельно:
  на стек данных кладётся соотв. число,
- константа записывается в код в соответствии с размером числа:
  - как byte: 0..255, 
  - как number - знаковая -32768..+32767

### Команды

Обработка ошибок будет реализована позже, возможно. 
Сейчас есть assert, raise, встроенные сообщения и обработчики python, 
которые считаются достаточными.

#### Общие

`noop`        
- код 0  
- пустая операция

`stop`        
- код 1  
- завершить программу

`end`        
- код 2
- конец кода, завершить программу

#### Стековые

`dup`       
- код 12 
- удвоить вершину стека
  - (при ошибке останов)
  - (при переполнении стека останов)

`drop`      
- код 13 
- сбросить вершину арифм. стека
  - (при ошибке останов)

`rot`       
- код 14 
- перенести [DS0]-ое число на вершину
  - (при ошибке останов)

`over`     
- код 15 
- скопировать  [DS0]-ое число на вершину
  - (при ошибке останов)
  - (при переполнении стека останов)

`swap`      
- код 16 
- обменять два верхних элемента стека
  - (при ошибке останов)

`dsrs`       
- код 10 
- перенести вершину стека данных на стек возвратов (DS > RS)
  - (при ошибке останов)
  - (при переполнении стека останов)

`rsds`       
- код 11 
- перенести со стека возвратов на стек данных (RS > DS)
  - (при ошибке останов)
  - (при переполнении стека останов)

#### Строки и символы, числа - константы

`char` c
- код 70
- положить на DS0 код символа с

`space`
- код 71
- положить на DS0 код пробела 32

`string` str
- код 72
- положить на DS0 адрес строки в кодофайле
- строка холлеритовская, т.е. 1ый байт = длина строки
- потом строку можно обрабатывать, напр., печатать
- строки не содержат пробелов
- т.о. их можно получать просто по split(input_line)

`byte`   число  
- код 73, n  
- загрузить число 0..255 на вершину стека
  - (при переполнении стека останов)

`number` число  
- код 74, n  
- загрузить число (размером с машинное слово) на вершину стека
  - (при переполнении стека останов)

`addr` мета  
- код 75, n  
- положить адрес метки как беззнаковое число на вершину стека
  - (при переполнении стека останов)

Потом можно будет добавить операции с символами и строками,
напр., вхождение символов и подстрок, склеивание строк, пр.

#### Арифметика

`neg`        
- код 20  
- смена знака вершины стека
  - (при ошибке "пустой стек" - останов)
  - (при арифм. ошибке взводится флажок ошибки)

`add`        
- код 21  
- сложение двух верхних элементов стека
  - (при переполнении взводится флажок переполнения)
  - (при ошибке "пустой стек" - останов)
  - (при арифм. ошибке взводится флажок ошибки)

`sub`       
- код 22  
- вычитание двух верхних элементов стека
  - (при переполнении взводится флажок переполнения)
  - (при ошибке "пустой стек" - останов)
  - (при арифм. ошибке взводится флажок ошибки)

`mul`        
- код 23  
- умножение двух верхних элементов стека
  - (при переполнении взводится флажок переполнения)
  - (при ошибке "пустой стек" - останов)
  - (при арифм. ошибке взводится флажок ошибки)

`div`        
- код 24  
- деление нацело двух верхних элементов стека
  - (при переполнении взводится флажок переполнения)
  - (при ошибке "пустой стек" - останов)
  - (при арифм. ошибке взводится флажок ошибки)

`mod`        
- код 25  
- остаток от деления нацело двух верхних элементов стека
  - (при переполнении взводится флажок переполнения)
  - (при ошибке "пустой стек" - останов)
  - (при арифм. ошибке взводится флажок ошибки)

`not`        
- код 26  
- отрицание 
  - (не 0 => 0, 0 => 1)
  - (при ошибке "пустой стек" - останов)

`random`
- код 27 
- случайное число
  - 0..65535
  - (при ошибке "переполнение стека" - останов)

#### Переходы

Метки определены командой `label имя`.

Каждая метка может быть определена только 1 раз. 
TODO: Повтор -- ошибка.

Допустимы ссылки вперёд на определённые далее метки.

Отсутствие в программе определения метки, на которую сделан переход -- ошибка.
Код не будет сформирован.
Будет выдано сообщение об ошибке.

Компилятор может создавать свои метки (специального вида).

`jump` метка  
- код 30   
- безусловный переход

`jeq` метка   
- код 31  
- анализ вершины стека, == 0

`jne` метка   
- код 32  
- != 0

`jge` метка   
- код 33  
- >= 0

`jgt` метка   
- код 34  
- > 0

`jle` метка   
- код 35  
- <= 0

`jlt` метка   
- код 36  
- < 0

`jof` метка   
- код 37  
- если поднят флаг переполнения
- проверить можно после операции, которая подняла флаг,
  флаг сбрасывается перед следующей аналогичной операцией
- это простая ошибка, которую можно и нужно обрабатывать
- возникает только при выполнении арифметических операций

`jef` метка   
- код 38  
- если поднят флаг ошибки
- проверить можно после операции, которая подняла флаг,
  флаг сбрасывается перед следующей аналогичной операцией
- это все серьёзные ошибки, которые в ЯВУ должны приводить к прерыванию,
  напр., деление на 0
- в программе обычно только поднимается флаг, а результат ставится по умолчанию
  (напр., при делении на 0 или получении остатка пишется 0)

#### Вызовы

`calld` метка  
- код 40  
- вызов подпрограммы (адрес возврата (CP+2) - на стек возвратов)
  - (при переполнении стека останов)
  - CP = метка

`calli` 
- код 41  
- вызов подпрограммы (адрес возврата взять состека DS0) - на стек возвратов)
  - (при переполнении стека останов)
  - CP = метка

`return`         
-код 43
- возврат из подпрограммы (берёт адрес возврата со стека возвратов)
  - (при опустошении стека останов)

#### Память

`fetch`      
- код 50  
- значение из ячейки памяти [DS0] копируется на стек данных

`store`      
- код 51  
- значение DS1 записывается в память по адресу [DS0], DS0 и DS1 удаляются

Память изначально заполнена нулями.

#### Ввод-вывод

`printnum`       
- код 60 
- печать числа с вершины стека, затем пробел
  - (при ошибке останов, вывода стека нет)

`printchar`    
- код 61
- печать символа с кодом DS0
  - (при ошибке останов)

`println`    
- код 62 
- печать перевода строки
  - (не рекомендуется делать явно number 13; printchar; )

`show`      
- код 63 
- вывод стеков и сведений об остальном состоянии машины (кратко)

`dump`      
- код 64
- вывод стека и дамп памяти и всего вообще состояния машины

`wait`      
- код 65 
- пауза, ждать нажатия Enter

`inputnum`     
- код 66 
- пауза, ввести число от пользователя
  - (число -128..127, знак сохранется, число остаётся по модулю 128)
  - (при ошибке - взводится флаг ошибки, выполнение продолжается)
  - (при переполнении стека останов)

`inputchar`     
- код 66 
- пауза, ввести символ от пользователя
  - (число 0..255, знак сохранется, число остаётся по модулю 128)
  - (при ошибке - взводится флаг ошибки, выполнение продолжается)
  - (при переполнении стека останов)

`printstr` 
- код 67 
- печать строки, адрес холлеритовской строки лежит на DS0
  - (только печатные символы ASCII)
  
#### Управляющие макросы

##### Условия

```
... <bool> if ...true-branch... else ...false-branch... then
... <bool> if ...true-branch... then
```

  - могут быть вложенными
  - bool = логическое значение
  - как в языке Forth

##### Циклы 

```
... <rept> do ...commands... loop ...
... begin ...commands... <bool> while ...commands... repeat ...
```

  - могут быть вложенными,
  - rept = число повторений 
    - (может использоваться RS)
  - bool = логическое значение
  - как в языке Forth

##### Макросы

Макросы (макроопределения) - блоки кода (возможно, с параметрами),
которые могут подставляться в разных местах программы буквально
(с подстановкой фактических параметров вместо формальных, если есть).

Команды внутри макроса записываются по одной на строке 
или сразу несколько команд в одной строке.

Ограничитель макроса -- пустая строка после него
(в определение не входит).

имя-макроса 
- идентификатор, 
- начинается с подчерка (_),
- не должно совпадать с именами команд,
- д.б. уникальным.

Макросы не могут вкладываться друг в друга,
ни при описании,
ни при вызове.

###### макросы без параметров

создание макроса:

```
macro _имя-макроса
команды...
пустая строка
```

использование макроса:

```
_имя-макроса
```

###### макросы с параметрами

создание макроса:

```
macro _имя-макроса
команды... с использованием переменных $0, $1, ... $9
пустая строка
```

использование макроса:

```
_имя-макроса 0 1 2 3 4 5 6 7 8 9
```

- значения 0..9 подставляются в текст макроса

Ошибки
------------------------------------

TODO: будут реализованы позже.

### Ошибки времени компиляции (compile-time errors)

- C1. Incorrect command format. - Неправильный формат команды.
- C2. Bad number. - Недопустимое число (не целое, большая абс. величина, пр.)
- C3. Program is too large. - Слишком большой размер программы.
- C4. Not existing opcode. - Несуществующий код операции.
- C5. Incorrect operand. - Неправильный операнд.
- C6. Undefined label. - Неопределённая метка.
- C7. Too many labels. - Слишком много меток.
- C8. Multiple label. - Повторная метка.
- C9. Wrong quoted string. - Неправильная строка в кавычках.
- C10. Incorrect character. - Недопустимая литера (не ASCII).

### Ошибки времени исполнения (run-time errors)

- R1. DS empty. - Опустошение стека данных.
- R2. RS empty. - Опустошение стека возвратов.
- R3. DS overflow. - Переполнение стека данных.
- R4. RS overflow. - Переполнение стека возвратов.
- R5. Zero divide. - Деление на ноль.
- R6. Not existing opcode. - Несуществующий код операции.
- R7. Incorrect operand. - Неправильный операнд.

Формат файла с кодом (кодофайла)
------------------------------------

### Версия 0.

файл: заголовок байт-код КС

заголовок: `SM`01 
- где 01 - версия кода

Байт-код заканчивается на `STOP` (1) и/или `END` (2).

Таких кодов может быть несколько.

КС: контрольная сумма, 
- в вер.0 это 1 байт, простая КС, остаток от деления всего кодофайла на 256 (без самой КС).

### Версия 1.

файл: заголовок байт-код

заголовок: `SM0`10 
- где 10 - версия кода

Байт-код заканчивается на `STOP` (1) и/или `END` (2).

Таких кодов может быть несколько.

В заголовке м.б. ещё и другие поля описаний.

Возможно, все тексты и прочие описания дописываются в конец кодофайла.

Программа размещена в кодофайле со смещения 4,
байты 0..3 являются маркером файла (SM) с добавление версии (10).

История версий программы
------------------------------------

### Версия 1.

Программа ksmc, компилятор в байт-код
------------------------------------

Вызов: 
```bash
python ksmc [параметры] program
```

Параметры:
program - имя программы без расширения
(расширение при его наличии будет проигнорировано).

Результат:
- файл `программа.smb`
  - байт-код программы
- файл `программа.sml`
  - протокол работы компилятора

Программа ksmr, интерпертатор байт-кода
------------------------------------

Вызов: 
```bash
python ksmr [параметры] program
```

Параметры:
program - имя программы без расширения
(расширение при его наличии будет проигнорировано).

Результат:
- файл `программа.smo`
  - вывод программы
- файл `программа.sml`
  - протокол работы программы

Программа ksmd, декомпилятор байт-кода
------------------------------------

Вызов: 
```bash
python ksmd [параметры] program
```

Параметры:
program - имя программы без расширения
(расширение при его наличии будет проигнорировано).

Результат:
- файл `программа.smd`
  - декомпилированный код программы
- файл `программа.sml`
  - протокол работы декомпилятора

Для удобства запуска сделаны соответствующие bash-файлы с параметрами.

### Описание команд - Краткий справочник

Версия: 01 = Mm, старшая и младшая.

#### Общие команды

| операция | код | описание |
| - | - | - |
| noop | 0 | пустая операция, нет действий |
| stop | 1 | завершить программу |
| end | 2 | конец кода, конец работы, все оставшиеся строки файла игнорируются |

#### Стековые

| операция | код | описание | 
| - | - | - |
| dsrs | 10 | перенос DS -> RS | 
| rsds | 11 | перенос RS -> DS | 
| dup | 12 | удвоить вершину DS | 
| drop | 13 | сбросить вершину DS | 
| rot | 14 | перенести [DS0]-ое число на вершину DS | 
| over | 15 | скопировать  [DS0]-ое число на вершину DS | 
| swap | 16 | обменять DS0, DS1 | 

#### Арифметика

| операция | код | описание | 
| - | - | - | 
| neg | 20 | смена знака DS0 | 
| add | 21 | DS1 + DS0 | 
| sub | 22 | DS1 - DS0 | 
| mul | 23 | DS1* DS0 | 
| div | 24 | DS1 // DS0 |  
| mod | 25 | DS1 % DS0 | 
| not | 26 | отрицание !DS0 | 
| random | 27 | случайное число 0..65535 на DS | 

#### Переходы

| операция | код | описание | 
| - | - | - | 
| jump метка | 30, метка | безусловный переход | 
| jeq метка | 31, метка | DS0 =0 | 
| jne метка | 32, метка | DS0 !=0 | 
| jge метка | 33, метка | DS0 >=0 | 
| jgt метка | 34, метка | DS0 >0 | 
| jle метка | 35, метка | DS0 <=0 | 
| jlt метка | 36, метка | DS0 <0 | 
| jof метка | 37, метка | по флагу переполнения | 
| jef метка | 38, метка | по флагу ошибки | 

#### Вызовы

| операция | код | описание | 
| - | - | - | 
| calld метка| 40, метка | вызов подпрограммы непосредственно, адрес возврата в RS | 
| calli | 41 | вызов подпрограммы косвенно, адрес возврата в RS | 
| return | 42 | возврат из подпрограммы по RS0 | 

#### Память

| операция | код | описание | 
| - | - | - | 
| fetch | 50 | [DS0]@ -> DS0| 
| store | 51 | DS1 -> [DS0]| 

#### Ввод-вывод

| операция | код | описание | 
| - | - | - | 
| printnum | 60 | печать числа DS0, затем пробел | 
| printchar | 61 | печать символа с кодом DS0, без пробела | 
| println | 62 | печать перевода строки | 
| show | 63 | вывод стеков и сведений о состоянии машины (кратко) | 
| dump | 64 | вывод стеков и дамп памяти и состояния машины (полно) | 
| wait | 65 | пауза, ждать нажатия Enter | 
| inputnum | 66 | пауза, ввести число от пользователя, DS0 = число | 
| inputchar | 67 | пауза, ввести символ от пользователя, DS0 = число | 
| printstr | 68 | печать строки, адрес которой лежит на DS0, без пробела | 

#### Символы и строки, числа - константы

| операция | код | описание | 
| - | - | - | 
| char символ | 70, символ | DS0 = код символа| 
| space | 71 | DS0 = код пробела | 
| string строка | 72, строка | DS0 = адрес холлеритовской строки в кодофайле | 
| byte n | 73, n | загрузить число 0..255 на вершину DS | 
| number n | 74, n | загрузить число (размером с машинное слово) на вершину DS | 
| addr метка | 75, метка | загрузить адрес метки на вершину DS | 

Темы для учебного курса
------------------------------------

Применение тем учебных курсов по информатике

1. макросы: 
для макропроцессоров, ассебмлеров и языков низкого уровня; `#define` в C.

2. псевдокоманды для циклов и условий: 
типичное для ассемблеров и языков низкого уровня; `#ifdef` в С.

3. прямые и косвенные ссылки для меток: 
перемещающие и связывающие загрузчики (линкеры); 
независимая разработка и компиляция модулей с последующим их связыванием.

4. метки: 
числовые (натуральные числа) и/или символические (идентификаторы); 
языки с явными переходами, спор между числовыми и символическими;
неявные компиляторные метки.

5. контрольная сумма (КС): 
различные способы; необходимость КС; здесь простая версия.

6. версия программы: 
важность проверки соответствия программы и обрабатываемого ею кода,
причём в варианте версии старшая.младшая 
со своими значениями для каждой.

7. константы:
  а. польза мнемоничных обозначений и, соответственно, поддержки в ЯП таких
     обозначений,
  б. многоэтапная обработка конструкций в ЯП на этапе компиляции;
     в данном случае -- 3-этапная.

Примечание: 
этот текст удобно смотреть в редакторе, поддерживающем разметку markdown,
напр., в MS VS Code, с соответствующими плагинами,
но не обязательно.

Примеры программ
------------------------------------

К проекту прилагают несколько простых программ, иллюстрирующих работу стековой машины.

Они находятся в файлах вида `progXX.smt`.

| файл | описание | 
| - | - | 
| prog01 | простые тесты по работе стеков, печать чисел, работа с памятью, вызовы непосредствнные, безусловные переходы | 
| prog02 | метки, условные переходы | 
| prog03 | факториал 7, стек возвратов | 
| prog04 | 1! .. 7!, подпрограммы, красивая печать | 
| prog05 | косвенный вызов подпрограмм | 
| prog06 | строки и символы | 
| prog07 | условные и циклические операботы как псевдокоманды, простые и вложенные | 
| prog08 | макросы, с и без параметров | 
| prog09 | числа Фибоначчи | 
| prog10 | числовые константы | 


***Конец описания.***
